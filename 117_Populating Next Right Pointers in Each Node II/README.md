# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 117_Populating Next Right Pointers in Each Node II（填充同一层的兄弟节点 II）
## 问题描述与输入输出
给定一个二叉树

	struct TreeLinkNode {
	  TreeLinkNode *left;
	  TreeLinkNode *right;
	  TreeLinkNode *next;
	}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。
如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。

说明:

* 你只能使用额外常数空间。
* 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。



### 问题示例

	示例1：
	给定二叉树，
	输入：
		 1
	   /  \
	  2    3
	 / \    \
	4  5     7
	输出：
		1 -> NULL
	   /  \
	  2 -> 3 -> NULL
	 / \    \
	4->5 ->  7 -> NULL
	

函数输入与输出：
* 输入：
	* struct TreeLinkNode *root：给定的二叉树头结点指针

* 输出：
	* void : 原地修改

## 思路			
### 双指针从上到下、从左到右遍历法

	本题注意不是完美二叉树了。这意味着要在116题的代码上稍做修改。
	方法也是从上到下（充分利用上层调整后的结果），从左到右一步步解决问题。
	p_level_bigin记录本层的最左边结点指针，p_level_travese记录本层的遍历节点指针
	比如：
		1
	   /  \
	  2    3
	 / \    \
	4  5     7
	先遍历第一层：
		1 -> NULL
	   /  \
	  2    3
	 / \    \
	4  5     7
	遍历第二层：
		1  -> NULL
	   /  \
	  2 -> 3 -> NULL
	 / \    \
	4  5     7
	遍历第三层：
		1  -> NULL
	   /  \
	  2 -> 3 -> NULL
	 / \    \
	4->5 -> 7 -> NULL（注意此时如何寻找7，方法就是寻找2后面的第一个有子树的节点，且左子树优先找，右子树后找）
				 				 	
## 拓展与思考：
### 拓展
可以用来恢复残缺的树结构（比如图书馆书是二叉存储的，但是每年都会有书丢了，于是需要每年都要重新列表）。
### 思考
本题给定的树不是完美二叉树，我们照样可以利用116题的代码稍微修改即可，当然你也可以利用递归实现。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
