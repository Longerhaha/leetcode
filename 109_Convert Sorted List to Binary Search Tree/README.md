# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 109_Convert Sorted List to Binary Search Tree（将有序链表转换为二叉搜索树）
## 问题描述与输入输出
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
### 问题示例

	示例1：
	输入：
	给定有序数组: [-10,-3,0,5,9],

	输出:
	一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
		  0
		 / \
	   -3   9
	   /   /
	 -10  5
	

函数输入与输出：
* 输入：
	* struct ListNode* head: 有序链表的头结点指针
* 输出：
	* struct TreeNode* : 构成的二叉搜索树的根节点指针

## 思路			

### 二分法
	
	记录当前链表中间的数（需要耗一定的时间，因为只能从链表的头一个一个往后找），然后左、右两路递归。

### DFS

	phead初始化为指向单链表头结点指针的二级指针，然后深度递归。
	递归结束条件：size = 0，然后return NULL；
	否则：
	（1）申请节点
	（2）节点的左子树为递归size/2的返回指针。
	（3）左路递归结束后，为节点赋值(*phead)->val，同时(*phead)指向链表的下一个节点指针。
	（4）节点的右子树为递归size-1-size/2（左子树size/2，自己也是个节点）的返回指针。
## 拓展与思考：
### 拓展
如果给定的链表是无序的呢？
### 思考
本题针对的是链表，如果使用二分法则必须有查找操作，但是这个查找还是有很大代价的。使用DFS则相对来说算法所花费的时间少，因为不需要查找操作。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
