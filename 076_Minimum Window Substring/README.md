# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 076_Minimum Window Substring（最小覆盖子串）
## 问题描述与输入输出
给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。

注意:
不能使用代码库中的排序函数来解决这道题。

如果 S 中不存这样的子串，则返回空字符串 ""。

如果 S 中存在这样的子串，我们保证它是唯一的答案。

### 问题案例

	示例1：
	输入: S = "ADOBECODEBANC", T = "ABC"
	输出: "BANC"
	

函数输入与输出：
* 输入：
	* char* s:字符串S
	* char* t:字符串T
	
* 输出：
	* char*：最小覆盖子串的字符串

## 思路			
### 一趟扫描

	dict_t记录字符串t中出现的频数，若无出现则是0
	start记录最小覆盖子串的起始位置
	end记录最小覆盖子串的结束位置
	min_window记录最小覆盖子串的窗口大小
	num_s记录字符出现的次数

	有效字符：若字符串s的字符在t中出现且不超过t中该字符出现的个数则为有效字符

	过程：每次统计s中的字符个数和有效字符，一旦有效字符的个数与t中的字符个数相等时，则进行判断。
		判断： （1）首先跳过无效字符和多余有效字符，即更新start
			   （2）计算窗口，如果窗口比上一个窗口小，则更新end位置
			   （3）抛弃该窗口的第一个有效字符，继续查找下一个窗口
	
	例子：  s = "acbbaca"
	        t = "aba"
		  
		    dict_t['a'] = 2;
			dict_t['b'] = 1;
			
			s从0遍历到4时，s中的有效字符为3（第一个b是有效字符，第二个b不是有效字符），与t中的字符相等。
			然后判断：
			（1）start初始化为-1，于是从start+1开始，s[0] = 'a'为有效字符，于是start=0；
			（2）窗口为4-0+1=5，小于初始化窗口，最小窗口更新为5。
			（3）抛弃"acbba"中的'a'，有效字符减1，num_s['a']字符个数减1，继续查找下一个窗口
			
			s遍历到下一个a，即i=6，有效字符为3，与t中的字符相等。
			然后判断：
			（1）start为0，于是从start+1=1开始，s[1] = 'c'为无效子串，s[2]='b'为多余有效字符（因为num_s['b']=2>dict_t['b']=1），s[3]='b'为有效字符，于是start=3；
			（2）窗口为6-3+1=4，小于上一个窗口，最小窗口更新为4。
			（3）抛弃"baca"中的'a'，有效字符减1，num_s['a']字符个数减1，继续查找下一个窗口
			
			i=7>7不成立，找到了最小的窗口。
			注意：注意start位置不一定是最小窗口的位置，好比s="acbbacaxxxb"，t="abc"这时候start会指向第二个a的位置，即start=4，这时候end=6，min_window=4。
			如果你从start开始就会错误，正确的做法是根据end去修正start的位置。
			


	
			
## 拓展与思考：
### 拓展
本题与28题[实现strStr()](https://leetcode-cn.com/problems/implement-strstr/description/)有异曲同工之妙。都可以采用一遍扫描，
本题是子串，不要求顺序与t中一致，实现strStr()则是要求一样的顺序，后者正是因为这个要求才有了KMP、SUNDAY等算法。
### 思考
本题滑动是s中的窗口，实现strStr()则是滑动t的窗口，两者都可以使用一遍扫描方式，很有意思。
		  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
