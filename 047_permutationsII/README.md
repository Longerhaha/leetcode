# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 047_permutations II(全排列2)
## 问题描述与输入输出
	
### 问题描述
给定一个可包含重复数字的序列，返回所有不重复的全排列。

### 问题案例
	
	输入: [1,1,2]
	输出:
	[
	  [1,1,2],
	  [1,2,1],
	  [2,1,1]
	]
		
### 输入与输出
* 输入：
	* int nums：无重复数字的序列的头指针
	* numsSize：无重复数字的序列的个数
	* returnSize:全排列的数目
	
* 输出：int** 全排列数组的二维数据的头节点指针

## 思路			
### 基于有条件交换的深度优先递归方法（回溯算法）
46题全排列由于是无重复数字，所以是无条件交换。本题由于不能是重复的全排列，所以需要有条件交换。
这里的条件交换准则对应回溯算法里面的边界函数。46题和47题的约束函数都是一样的。条件交换准则是
当前待交换的数据在要交换的数据与待交换的数据之间没有出现，也就是data[start] ... data[end-1]中
没有和data[end]重复的数据一样即可以交换。

注意不要误以为以下[两种做法](https://www.cnblogs.com/TenosDoIt/p/3662644.html)能够去重：（1）最开始先对数组进行排序，以后每次交换时，只要保证当前
要交换的元素和前一个元素不同，这种做法是错误的，虽然开始进行了排序，但是元素的交换会使数组再次
变的无序
（2）每次进入递归函数permuteRecur时，对从当前索引开始的子数组排序，这种做法也是错误的，因为每
次交换元素后，我们要恢复交换的元素，如果在递归函数内排序，就不能正确的恢复交换的元素。 

刚开始的时候我犯了第一种错误，第一种错误比如交换后含有子串[-1 1 -1 1]的数字序列，那么使用第一种方法就会有重复的序列。

第二种错误很明显。

## 拓展与思考：
### 拓展
这类的方法都是用[回溯算法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495)做，针对不同问题边界函数与约束函数不同，
### 思考
本题的算法时间复杂度是O（n*n!），由于是排列回溯的，所以基础是O（n!），又每次都要判定边界函数，故是O（n*n!）。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
