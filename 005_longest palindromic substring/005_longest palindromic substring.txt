/*该种方法失败
//对付不了aaaa这样的回文串
//0不是回文数
//1是回文数
int JudgePalindrome(char *s, int start, int end){
    int i;
    int judge_num = (end-start+1)/2; //需要判断的个数
    for(i=0; i<judge_num; i++){
        if(s[start+i] != s[end-i])
            return 0;
    }
    return 1;
}
//动态规划+表
char* longestPalindrome(char* s) {
    int *dic = (int *)malloc(128*sizeof(int));
    memset(dic, -1, 128*sizeof(int));
    
    int lp_start=0;//最长回文子串的起始位置
    int lp_end=0;//最长回文子串的终点
    int i;
    int len_str = strlen(s);
    for(i=0; i<len_str; i++){
        if(-1 != dic[s[i]]){//之前出现过
            if(JudgePalindrome(s,dic[s[i]], i) && ((lp_end-lp_start)<(i-dic[s[i]]))){ 
                //有更长的回文子串则更新位置
                lp_end = i;
                lp_start = dic[s[i]];
            }      
        }
        dic[s[i]] = i;//记录上一个出现的位置
    }
    //释放掉存储该字符的前一个位置的表
    free(dic);

    for(i=0; i<(lp_end-lp_start+1); i++){
        s[i] = s[lp_start+i];//拷贝最长回文子串至字符串头地址，逐个替换掉
    }
    s[i] = 0;
    return s;
}*/



//基于动态规划的方法（超出了时间限制）
//状态方程
//                        1                           i=j
//lp[i][j] =        (d[i] == d[j])                    i=j-1
//            (d[i] == d[j]) && (lp[i+1,j-1])         j-i>1 
//
#define Max(a, b) (a>=b?a:b)
char* longestPalindrome(char* s) {
    int len = strlen(s);
    
    int *lp = (int*)malloc(sizeof(int)*len*len);    
    memset(lp, 0, len*len*sizeof(int));
    
    int i,j;
    int pre = 0;
    int maxLen_lp = 0;
    for(j=0; j<len; j++){
        for(i=0; i<=j; i++){
            if((j-i)>1)
                lp[i*len+j] = ((s[i] == s[j]) && lp[(i+1)*len+j-1]);
            else
                lp[i*len+j] = (s[i] == s[j]);
            
            if(lp[i*len+j] && (maxLen_lp<(j-i+1))){// 如果是回文子串
                maxLen_lp = j-i+1;
                pre = i;
            }
        }
    }
    
    for(i=pre; i<(pre+maxLen_lp); i++)
        s[i-pre] = s[i];
    
    s[maxLen_lp] = 0;
    return s;  
}