# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 144_Binary Tree Preorder Traversal（二叉树的前序遍历）
## 问题描述与输入输出
给定一个二叉树，返回它的_前序_遍历。

__进阶__: 递归算法很简单，你可以通过迭代算法完成吗？


### 问题样例

	示例1：
	输入: [1,null,2,3]
	1
	 \
	  2
	 /
	3

	输出: [1, 2, 3]
	

函数输入与输出：
* 输入：
	* struct TreeNode* root：二叉树的根节点指针
	* int* returnSize：前序遍历后，存储二叉树中序遍历数据的长度(*returnSize)


* 输出：
	* int*: 存储二叉树前序遍历结果的指针

## 思路			
### 递归

	1. 如果root==NULL，结束递归，否则进行2、3、4
	2. 把root的数据保存下来，计数加1
	3. 递归左孩子
	4. 接着，再递归右孩子

### 基于堆栈的非递归解法
	
	递归其实就是压栈出栈的过程，所以该实现方法其实就是自己写堆栈，注意堆栈的元素是struct TreeNode*类型的。
	
### Morris遍历（非递归）
	
	参考来源:[二叉树的遍历](https://blog.csdn.net/yc461515457/article/details/78082042)。
	1. 如果当前节点的左孩子为空，记录当前节点，并将其右孩子作为当前节点。
	2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。
	a) 如果前驱节点的右孩子为空，记录当前节点，并将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。
	b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。当前节点更新为当前节点的右孩子。
	3. 重复以上1、2直到当前节点为空。
	其与先序遍历的差别只是数据记录节点不一样，先序遍历记录节点在1和2(a)，中序遍历记录节点在1和2(b)。
	
## 拓展与思考：
### 拓展
可以了解下[线索二叉树](https://baike.baidu.com/item/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91)。
### 思考
稍微从中序遍历变形即可写出前序遍历的三种代码。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
