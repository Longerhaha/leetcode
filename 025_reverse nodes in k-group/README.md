# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 025_reverse nodes in k-group（k个一组翻转链表）
## 问题描述与输入输出

### 问题描述

给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。

### 问题案例

	给定这个链表：1->2->3->4->5

	当 k = 2 时，应当返回: 2->1->4->3->5

	当 k = 3 时，应当返回: 3->2->1->4->5
    
	你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

## 思路			
这个与浙江大学陈越老师数据结构课里面的反转链表一样，不过陈越老师为了不让大家作弊，规定了结构体为:

	struct node{
		AddrType cur_addr;
		ValType  val;
		AddrType next_addr
	}

本题也要求了你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换，所以大家就好好做吧。

思路就是nextHead不断指向后面的节点直到为空，preTail记录上一次反转链表的尾巴，每k个做一次反转，故nextHead记录该组反转链表的下一个头。
在k个反转中，需要pre, cur, next三个指针，每次cur的next指向pre，然后三个指针整体往后移一个，当next=nextHead时则跳出循环。

	
	k=4时的一个例子
	while(next != nextHead)
	preTail  ->	a[0]->a[1]->a[2]->a[3]   nextHead  
				   <--      	
	(1)			pre   cur   next   
						<--      	
	(2)				 pre   cur   next 
						
	(3)					   pre   cur     next(此时跳出循环) 
	跳出循环后:		   		  <--
	(4)					   pre   cur     next
	    ------------------------------
                                  	  |	
	preTail(指向cur) 	   pre   cur<-   next<--
			                                    | (指向next)
	(6)			a[0]----------------------------
    并返回a[0]节点的地址（即下一个需要反转的preTail）
	
	
## 拓展与思考：
### 拓展
如果按照浙江大学陈越老师数据结构课里面的反转链表给出的数据结构，你如何做反转链表？
### 思考
这个题目还是很有意思的，不仅需要记录前一个翻转链表的尾巴，而且在做翻转时还需要知道下一个头，而且翻转后你就不知道下一个的节点位置了，所以
操作翻转时需要pre, cur, next三个指针，细细思考后还是很有挑战性的。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
