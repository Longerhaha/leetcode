# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 074_Search a 2D Matrix（搜索二维矩阵）
## 问题描述与输入输出
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

* 每行中的整数从左到右按升序排列。
* 每行的第一个整数大于前一行的最后一个整数。

### 问题案例

	示例1：
	输入:
	matrix = [
	  [1,   3,  5,  7],
	  [10, 11, 16, 20],
	  [23, 30, 34, 50]
	]
	target = 3
	输出: true
	
	示例2：
	输入:
	matrix = [
	  [1,   3,  5,  7],
	  [10, 11, 16, 20],
	  [23, 30, 34, 50]
	]
	target = 13
	输出: false

函数输入与输出：
* 输入：
	* int** matrix:矩阵的数据的二维指针
	* int matrixRowSize：矩阵数据的行
	* int matrixColSize：矩阵数据的列
	* int target：搜索目标的值
	
* 输出：
	* bool 是否在这个二维数据搜索到了这个值

## 思路			
### 二分查找

首先二分定位行，然后二分定位列。定位行与定位列性质不一样，定位行是基于范围的定位，定位列是数据有无的定位。

算法的时间复杂度为O(logm)+O(logn)=O(log(mn))		
				
* 二分定位行

	递归规则：
	    如果小于中间，则肯定是我们要返回的行在[start, mid-1]
            等于中间，则直接返回该行
            大于中间，则行在[mid, end]
	递归结束条件：
		要分成两个，可能start=end,也可能end-start=1
		start=end: 
				比如[1;7;10],查找6
				第一轮start=0, end=2, mid=1 
					此时6<7,往左走
				第二轮start=0, end=0, mid=0
					此时1<6,返回0
		end-start=1:
				比如[1;7;10],查找8
				第一轮start=0, end=2, mid=1 
					 此时7<8,往右走
				第二轮start=1, end=2, mid=1
					 此时7<8,返回1
		上述两种情况都可以归纳于对最后[data[start], data[end]]区间的判断
		如果target区间在[data[end], +inf],则返回end
		如果target区间在[data[start], data[end]),则返回start
		如果target区间在(-inf, data[start]),则返回-1(代表所有数都比它大)
	
* 二分定位列

    定位了行后，问题就转化为一维的二分查找
	递归规则：
		target比中间小就往左走，等于中间返回mid，大于中间往右走	
	递归结束条件：
		start == end
		-1就说明在该行没有找到，否则返回所在的列
		
			
## 拓展与思考：
### 拓展
三维乃至多维的矩阵里面去搜索，甚至是有多个重复元素的搜索。
### 思考
本题还是很有意思的，特别是行二分搜索，这个是范围的搜索。列二分搜索相对简单，就是一个一维的搜索。
		  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
