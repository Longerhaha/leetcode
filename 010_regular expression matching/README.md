# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 010_regular expression matching(正则表达式匹配)
## 问题描述与输入输出
	
### 问题描述
给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

	'.' 匹配任意单个字符。
	'*' 匹配零个或多个前面的元素。

匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

	s 可能为空，且只包含从 a-z 的小写字母。
	p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
	
### 问题案例
	
	示例1
	输入:
	s = "aa"
	p = "a"
	输出: false
	解释: "a" 无法匹配 "aa" 整个字符串。
	
	示例2
	输入:
	s = "aa"
	p = "a*"
	输出: true
	解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。

	示例3
	输入:
	s = "ab"
	p = ".*"
	输出: true
	解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
	
	示例4
	输入:
	s = "aab"
	p = "c*a*b"
	输出: true
	解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
	
	示例5
	输入:
	s = "mississippi"
	p = "mis*is*p*."
	输出: false
	
	
### 输入与输出

* 输入：
	* char* s:待匹配字符串
	* char* p:匹配模板
	
* 输出: bool 是否匹配

## 思路			
### 动态规划（参考代码样例）

	dp[i + 1][j + 1]: if s[0..i] matches p[0..j]		
	dp[i+1][j+1] =  dp[i][j] && ('.' == p[j] || s[i] == p[j])   if p[j] != '*'   (1)
					dp[i + 1][j - 1] && j > 0) || (dp[i + 1][j] ||  
					(dp[i][j + 1] && j > 0 && ('.' == p[j - 1] || s[i] == p[j - 1])))   else  (2)

1.当p[j]!='*'时，若dp[i][j]是匹配的，则进一步判断增加了s[i]、p[j]后是否匹配。此时若p[j]为'.'(任意匹配)或者是s[i] == p[j]则匹配，这个很好理解。
2.当p[j]=='*'时，满足以下三个条件之一都可以认为是匹配。
	* 1.若dp[i + 1][j - 1]是匹配,则当前需要复制0个p[j-1]
	* 2.若dp[i + 1][j]是匹配,则当前需要复制1个p[j-1]
	* 2.若dp[i][j + 1]是匹配,则或者s的尾巴 s[i]与p[j-1]相同时需要复制2个p[j-1]或者当p(p[j-1]p[j])的尾巴是".*"时，此时需要生成两个数（可能相同也可能不同）。


## 拓展与思考：
### 拓展
百度了一下[正则表达式](https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215?fr=aladdin)，可以使用正则表达式来处理文本内容。
### 思考
本题难度真的是很高，需要考虑很多问题。动态规划方法需要合理安排，否则很可能思路错乱。我自己写的代码没有充分利用先前的信息，没有合理安排解决方案。
当然你可以使用基于字符串的方法，但是较为麻烦。动态规划思路还是简洁明了的。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
