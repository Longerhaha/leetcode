# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 044_wildcard matching(通配符匹配)
## 问题描述与输入输出
	
### 问题描述
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

	'?' 可以匹配任何单个字符。
	'*' 可以匹配任意字符串（包括空字符串）。

两个字符串完全匹配才算匹配成功。

	s 可能为空，且只包含从 a-z 的小写字母。
	p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
	
### 问题案例
	
	示例1
	输入:
	s = "aa"
	p = "a"
	输出: false
	解释: "a" 无法匹配 "aa" 整个字符串。
	
	示例2
	输入:
	s = "aa"
	p = "*"
	输出: true
	解释: '*' 可以匹配任意字符串。
	
	示例3
	输入:
	s = "cb"
	p = "?a"
	输出: false
	解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
	
	示例4
	输入:
	s = "adceb"
	p = "*a*b"
	输出: true
	解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".	
	
	示例5
	输入:
	s = "acdcb"
	p = "a*c?b"
	输入: false
	
	
### 输入与输出

* 输入：
	* char* s:待匹配字符串
	* char* p:匹配模板
	
* 输出: bool 是否匹配

## 思路			
### 动态规划（参考代码样例）

	dp[i + 1][j + 1]: if s[0..i] matches p[0..j]		
	dp[i+1][j+1] =  dp[i][j] && ('.' == p[j] || s[i] == p[j])   if p[j] != '*'   (1)
				 =	dp[i][j-1] || dp[i-1][j]    if p[j] == '*'  (2)

* 1. 当p[j]!='*'时，若dp[i][j]是匹配的，则进一步判断增加了s[i]、p[j]后是否匹配。此时若p[j]为'?'(任意匹配)或者是s[i] == p[j]则匹配，这个很好理解。
* 2. 当p[j]=='*'时，满足以下三个条件之一都可以认为是匹配。
	* 1.若dp[i][j-1]是匹配,则当前'*'匹配空字符串
	* 2.若dp[i-1][j]是匹配,则当前需要匹配一个字符。


## 拓展与思考：
### 拓展
与正则表达式一样，可以使用通配符来处理文本内容。
### 思考
本题相比于第10题的[正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/description/)来说相对简单一点，需要考虑的情况少了一点。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
