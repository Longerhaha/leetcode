# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 046_permutations（全排列）
## 问题描述与输入输出
给定一个没有重复数字的序列，返回其所有可能的全排列。
	
	示例1
	输入: [1,2,3]
	输出:
	[
	  [1,2,3],
	  [1,3,2],
	  [2,1,3],
	  [2,3,1],
	  [3,1,2],
	  [3,2,1]
	]

函数输入与输出：
* 输入：
	* int nums：无重复数字的序列的头指针
	* numsSize：无重复数字的序列的个数
	* returnSize:全排列的数目
	
* 输出：int** 全排列数组的二维数据的头节点指针

## 思路			
### 基于交换的递归方法    
	
	求1 2 3的全排列可以这么做
				 	 |-交换2与2-----交换3与3 ---123（1）
		|交换1与1----|
		|			 |-交换2与3---132（2）
		|
		|            |-交换1与1-----交换3与3 ---213（3）
		|        213 | 
	----|交换1与2----|	
		|		     |-交换1与3---231（4）
		|
		|            |-交换2与2-----交换3与3 ---321（5）
		|		 321 |
	    |交换1与3----|
					 |-交换2与1---321（6）

由组合数学我们可以知道对于n个不重复的数据，其全排列有n！个方案。通过上面的描述，我们可以获取求这道题目的思路。

首先从头到尾做交换，交换后递归，递归结束后恢复原来的顺序。

递归的时候一旦递归到最后一个数据，则结束递归，同时将数据复制到全排列二维数据的当前行，然后行加1。					 
					 				 	
## 拓展与思考：
### 拓展
[含重复数据但是不重复的全排列](https://leetcode-cn.com/problems/permutations-ii/description/)
### 思考
本题也可以采用非递归的方法，但是较为复杂。
		  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
