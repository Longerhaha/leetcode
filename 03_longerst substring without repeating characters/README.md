# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 03_longerst substring without repeating characters(无重复字符的最长子串)
## 问题描述与输入输出
	
### 问题描述
给定一个字符串，找出不含有重复字符的最长子串的长度。

### 问题案例
	给定 "abcabcbb" ，没有重复字符的最长子串是 "abc" ，那么长度就是3。
	给定 "bbbbb" ，最长的子串就是 "b" ，长度是1。
	给定 "pwwkew" ，最长子串是 "wke" ，长度是3。请注意答案必须是一个子串，"pwke" 是 子序列  而不是子串。
### 输入与输出

* 输入：char *:输入的字符串头指针
* 输出：最长子串的长度

## 思路			
1. [暴力搜索法](http://baijiahao.baidu.com/s?id=1596959005481205984&wfr=spider&for=pc)：最外层逐一算出以当前位置开头的字符串的最大子串的长度，
内层通过判断字符的不同（复杂度O（n））算出以当前字符开头的字符串的最大子串长度。算法时间复杂度为O（n^3），空间复杂度为O（1）。
2. 机智搜索法：暴力搜索里面有很多重复的搜索，浪费了很多时间。利用表记录上一次字符出现的位置（初始化为-1），并记录当前最大子串的起始位置（初始化为0）。
则当该字符上一次出现的位置大于最大子串的起始位置才需要确定是否是最大子串。这样子实现的复杂度为O（n），空间复杂度为0（128）。需要注意的是该方法有个特殊情况，
就是比如"hwpwabs"这种输入，若没有特殊处理，则最长子串为“wp”，但应该是“pwabs”。机智的你肯定知道利用起始位置和字符串长度以及最长子串的长度做个比较，然后就知道
谁最长了。     

## 拓展与思考：
### 拓展
机智搜索法的背后就是动态规划+Hash求解，有兴趣的可以去了解下。
### 思考
很多问题可以变为动态规划，从而减少复杂度。动态规划的应用很多，大家可以好好留意。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
