# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 102_Binary Tree Level Order Traversal（二叉树的层次遍历）
## 问题描述与输入输出
给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。
### 问题示例

	示例1：
	输入：
	给定二叉树: [3,9,20,null,null,15,7],
	  3
	 / \
	9  20
      /  \
	 15   7
	输出:
	[
	  [3],
	  [9,20],
	  [15,7]
	]
	

函数输入与输出：
* 输入：
	* struct TreeNode* root：二叉树的根节点指针
	* int** columnSizes：（*columnSizes）是指向数组的指针，也就是说columnSizes是二级指针
	* int* returnSize：*returnSize为二叉树的层数（深度）。
* 输出：
	* int**: 层次遍历结果的二级指针

## 思路			
### 递归
	
	深度优先遍历，每次递归进来，记录当前对应层的数据与数目。
	但是这种办法有局限，意味这你得申请固定长度的二维数据。对于带有偏斜的树（比如2048级所有节点都只有左孩子的二叉树）
	和完美二叉树（比如20层，意味这20层得申请2^20个节点，内存会爆炸）的测试数据无法通过。
	  3
	 / \
	9  20
      /  \
	 15   7
	讲一下这个遍历的过程吧:
	[1]遍历3，此时深度为0, res[0][0] = 3, (*columnSizes)[0] = 1,接着遍历左子树9;
	[2]遍历9，此时深度为1, res[1][0] = 9, (*columnSizes)[1] = 1,左、右子树都为空，返回第1步;
	[3]第1步的左子树遍历完了，遍历右子树20，此时深度为1, res[1][1] = 20, (*columnSizes)[1] = 2,接着遍历左子树15;
	[4]遍历15，此时深度为2, res[2][0] = 15, (*columnSizes)[2] = 1,左、右子树都为空，返回第3步;
	[5]遍历20的右子树7，此时深度为2, res[2][1] = 7, (*columnSizes)[2] = 2,左、右子树都为空，结束（层层递归结束）。
	结果：
	[
	  [3],
	  [9,20],
	  [15,7]
	]
	
### 基于队列和BFS的层次遍历

	每遍历一层，将该层的搜索数据（数据在队列中）遍历一遍，每从队列中取出一个数据，则判断其是否有左右子树，若有则进队列。
	就这样子层层遍历，知道队列为空。
	  3
	 / \
	9  20
      /  \
	 15   7
	讲一下这个遍历的过程吧:
	[1]刚开始3在队列中，队列长度为1，于是该层遍历1次，3的左右子树都不为空，于是将9,20都进队；
	[2]队列长度为2，该层遍历2次，第一次从队列中取出9，其没有左右子树，第二次从队列中取出20，其有左右子树分别为15、7，进队；
	[3]队列长度为2，该层遍历2次，第一次从队列中取出15，其没有左右子树，第二次从队列中取出7，其没有左右子树；
	[4]队列为空，结束。
	结果：
	[
	  [3],
	  [9,20],
	  [15,7]
	]
		
## 拓展与思考：
### 拓展
如果让你从最底层遍历到最高层呢？
### 思考
本题很有意思，卡方法1，方法2用处更大。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
