# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 099_Recover Binary Search Tree（恢复二叉搜索树）
## 问题描述与输入输出
二叉搜索树中的__两个节点__(只有两个节点)被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

### 问题示例

	示例1：
	输入: [1,3,null,null,2]
	   1
	  /
	 3
	  \
	   2

	输出: [3,1,null,null,2]

	   3
	  /
	 1
	  \
	   2
	
	示例2：
	输入: [3,1,4,null,null,2]
	  3
	 / \
	1   4
	   /
	  2

	输出: [2,1,4,null,null,3]
	  2
	 / \
	1   4
	   /
	  3
	

函数输入与输出：
* 输入：
	* struct TreeNode* root：根节点指针
* 输出：
	* void: 原地修改树的结构，无需输出

## 思路			
### 利用Morris中序遍历恢复二叉搜索树

	1.中序遍历。
	2.当当前值比前一个值小的时候，前一个值要和后面的交换。
	3.再往后遍历，当当前值比前一个数小的时候，说明找到了第二个结点。然后将找到的两个结点交换。
	
	例子1：
	  3
	 / \
	1   4
	   /
	  2
	中序遍历结果为：1 3 2 4。
	3>2，第一个节点为3，第二个节点为2，后续无当前值比前一个数小。
	例子2：
	   1
	  /
	 3
	  \
	   2
	中序遍历结果为：3 2 1
	3>2，第一个节点为3，第二个节点为2。
	2>1，第二个节点为1，覆盖了第一步的第二个节点为2。
	
## 拓展与思考：
### 拓展
1、本题只有两个节点被错误交换，那如果是多个（4个、6个）被交换呢？似乎想不出常数空间的解决方案。只能把数取出来重新构建二叉搜索树了。
2、可以利用前序或者后续遍历吗？答案个人觉得不行，因为二叉搜索树前序或者后序遍历都不是有序的。
### 思考
如果你利用递归中序遍历，则不是常数空间的解决方案。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
