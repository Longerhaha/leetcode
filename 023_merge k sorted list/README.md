# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 023_merge k sorted list(合并K个排序链表)
## 问题描述与输入输出
	
### 问题描述
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
### 问题案例
	
	示例1
	输入:
	[
	  1->4->5,
	  1->3->4,
	  2->6
	]
	输出: 1->1->2->3->4->4->5->6

	
### 输入与输出

* 输入：
	* struct ListNode** lists  输入的二维结构体指针
	* int listsSize            待排序的链表个数
* 输出: struct ListNode*       合并后的链表的头结点指针

## 思路			

* 分而治之：21题是两个有序链表的合并，通过分治法可以实现时间复杂度O（nlogn）的解决方法。
* [最小堆排序](https://blog.csdn.net/ywk253100/article/details/22808495):思路就是先根据k个链表的k个头节点建立最小堆，然后删除堆顶，堆顶所在的链表下一个元素进堆，如此反复（注意若要是某一链表空了，则最小堆规模减1）。时间复杂度为O（nlogk）。

## 拓展与思考：
### 拓展
思考一下如果这k个链表是无序的，那该怎么做？分治法复杂度还是O（nlogn）？
### 思考
分治法、最小堆是常用的排序算法，分治法能把O（n）复杂度降为O（logn），最小堆排序能把O（n）复杂度降为O（logk）（k为最小堆节点数）。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
