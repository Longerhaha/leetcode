# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 128_Longest Consecutive Sequence（最长连续序列）
## 问题描述与输入输出
给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 O(n)。


### 问题示例

	示例1：
	输入：
	[100, 4, 200, 1, 3, 2]
	输出：
	4
	解释：
	最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

函数输入与输出：
* 输入：
	* int* nums: 输入数组的指针
	* int numsSize: 输入数组的长度


* 输出：
	* int : 找出最长连续序列的长度

## 思路			
### 哈希表左右连续查找法
	
	for( 数组里面的每个元素 )
		i. 如果当前值在哈希表内，则跳过本次循环
		ii.如果data[i]没有在哈希表，则：
			i. 添加其至哈希表。往左添加其至哈希表
			ii. 往左(不断减1)一直查找直至其左相邻的数不在哈希表内并记录左相邻的个数
			iii. 往右(不断加1)一直查找直至其右相邻的数不在哈希表内并记录右相邻的个数
			iiii. 当前数的相邻数的个数为左相邻的个数+右相邻的个数+1，如果该值大于过去相邻数的最大值，则更新最大值为当前值
	注：这种方法的时间复杂度偏高，特别是在输入的是连续的数据时时间复杂度可以达到O（n^2）
	
### 基于哈希表的动态规划法

	哈希表中key是输入数据，keyval存储的是以key为边界的最大连续长度
	1.初始化哈希表
	2.for（ 哈希表的每个元素x ）
		(i)  如果在哈希表内有该元素，则结束本次循环
		(ii) 如果不在哈希表内，则其keyval(x)= keyval(x - 1) + keyval(x + 1) + 1 （原因在于x不出现在当前的哈希表中，
			所以最大连续长度(x - 1)肯定是以x - 1结尾连续串，最大连续长度(x + 1)肯定是以x + 1开头的连续串）；
			然后将keyval(x)插入哈希表内，并更新边界keyval(x - keyval(x - 1))和keyval(x + keyval(x + 1))的值为keyval(x)
			（注意不需要去更新边界内部的值，因为他们本身已经在哈希表内，如果遇见他们会在(i)步骤中跳过）
	3.销毁哈希表

## 拓展与思考：
### 拓展
如果让你找出最长连续等差序列（差为2）的长度呢？
### 思考
本题利用哈希表可以解决问题，但是不知道为什么我的运行时间是200ms+，远大于4-20ms，明天再检查下这个问题。
上次commit问题解决了：
（1）哈希表左右连续查找法时间复杂度偏高，特别是在输入的是连续的数据时时间复杂度可以达到O（n^2），所以运行时间是200ms+。
（2）基于哈希表的动态规划法时间复杂度为O（n），每算一个数据的最大连续长度只要查哈希表里面的两个key即可，运行时间在20ms以内。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
