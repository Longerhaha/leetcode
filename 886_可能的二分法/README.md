# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 886_可能的二分法
## 问题描述与输入输出
### 问题描述

给定一组 N 人（编号为 1, 2, ..., N）， 我们想把每个人分进任意大小的两组。

每个人都可能不喜欢其他人，那么他们不应该属于同一组。

形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。

当可以用这种方法将每个人分进两组时，返回 true；否则返回 false。

### 问题示例

	示例1：
	输入: 
	N = 4, dislikes = [[1,2],[1,3],[2,4]]
	输出: 
	true
	解释：
	group1 [1,4], group2 [2,3]
	
	示例1：
	输入: 
	N = 3, dislikes = [[1,2],[1,3],[2,3]]
	输出: 
	false

	示例1：
	输入: 
	N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
	输出: 
	false
	
### 函数输入与输出：
* 输入：
	* int N: 给定的一组人数
	* int** dislikes: 不允许编组的数组的二级指针
	* int dislikesRowSize：不允许编组的数组的数目
	* int *dislikesColSizes：不允许编组的数组的列数（数组形式）的一级指针。
	
* 输出：
	* bool：是否存在分组的方案

## 思路			
### 基于邻接表的DFS
	
	该问题其实就是一个点着色的问题。
	1.建立邻接表
	2.初始化染色为0
	3.for( i = 1 ... N )
		如果存在节点i已经染色，则继续下一个节点；否则给该点染色1，并DFS查看是否有该节点的合理染色方案，若不存在，则返回false
		
	DFS过程如下；
	对节点 i 的每个邻接点 v
	    如果v被染色过，颜色与节点 i不同则继续，否则返回false；
		如果v未被染色过，则染成与节点 i相反的颜色，并DFS该节点，如果DFS（v）返回false则返回false
	返回true
	
## 拓展与思考：
### 拓展
暂无想法。
### 思考
本题相比于螺旋矩阵I和螺旋矩阵II更灵活了，需要加入边界有效判断。
		  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
