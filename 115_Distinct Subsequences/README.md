# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 115_Distinct Subsequences（不同的子序列）
## 问题描述与输入输出
给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。
（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）


### 问题示例

	示例1：
	输入：
	S = "rabbbit", T = "rabbit"
	输出：
	3
	如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。
	(上箭头符号 ^ 表示选取的字母)

	rabbbit
	^^^^ ^^
	rabbbit
	^^ ^^^^
	rabbbit
	^^^ ^^^
	
	示例2：
	输入：S = "babgbag", T = "bag"
	输出：5
	如下图所示, 有 5 种可以从 S 中得到 "bag" 的方案。 
	(上箭头符号 ^ 表示选取的字母)

	babgbag
	^^ ^
	babgbag
	^^    ^
	babgbag
	^    ^^
	babgbag
	  ^  ^^
	babgbag
		^^^



函数输入与输出：
* 输入：
	* char* s：字符串S的一级指针
	* char* t：字符串T的一级指针

* 输出：
	* int : 子序列的个数

## 思路			
### 动态规划

	(i) 如果当前字符不相等，则看s[i-1]与t[j]的不同序列个数;
	(ii)如果当前字符相等，则dp[i][j]分为包含该字符s[i]的子串与不包含字符s[i]的子串。
	即dp[i][j] = dp[i-1][j] + (s[i-1] == t[j-1]) ? dp[i-1][j-1]:0;
				 				 	
## 拓展与思考：
### 拓展
很有意思，可以拓展在文本搜索方面。
### 思考
本题使用动态规划较为简单，(ii)的思想和图论中计算生成树的个数（生成树的个数为包括某条边的生成树与不包括某条边的生成树的和）定理几乎一模一样。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
