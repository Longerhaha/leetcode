# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 022_valid parentheses（括号生成）
## 问题描述与输入输出
给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
例如，给出 n = 3，生成结果为：

	[
	  "((()))",
	  "(()())",
	  "(())()",
	  "()(())",
	  "()()()"
	]

函数输入与输出：
* 输入：
	* int n：生成括号的对数
	* int* returnSize：所有有效的括号的数目
* 输出：有效的括号的二维数据的头节点指针

## 思路			
### 递归方法    
left代表左括号的个数，right代表右括号的个数。递归的停止条件是left>=n，如果满足该条件则往里面塞右括号直到right等于n;
然后把该满足条件的有效括号的数据复制到下一个满足的有效的括号的数据里头，这样子处理（复制）的原因是在递归里面的形参是
第几个有效括号的指针，在递归结束后有效括号数目的值才更新(+1)，此时先前递归的值是上一个满足的有效的括号下标，通过这么
处理，我就不用想着去更新这些值了，而是由后续的递归去更新值了。

举个例子比如你递归获得了data[0] = "（（（）））"递归结束后，进入下一个递归"（（ ......"。
此时下标更新为1，left = 1, right = 1,但是data[1][0]、data[1][1]的数据我们是不知道的，因为这个数据是在下标0的时候有的。
通过把该满足条件的有效括号的数据复制到下一个满足的有效的括号的数据里头，我们在后续的递归就不用管这个问题了。
	
## 拓展与思考：
### 拓展
这题与[全排列](https://leetcode-cn.com/problems/permutations/description/)类似。
### 思考
刚开始一直卡在如何思路中描述的那个问题，仔细想了一下虽然该方法浪费了一些无效的复制操作，但是确实省心不少。
		  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
