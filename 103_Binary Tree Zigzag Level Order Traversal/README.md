# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 103_Binary Tree Zigzag Level Order Traversal（二叉树的锯齿形层次遍历）
## 问题描述与输入输出
给定一个二叉树，返回其节点值的锯齿形层次遍历。
（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
### 问题示例

	示例1：
	输入：
	给定二叉树 [3,9,20,null,null,15,7],
	  3
	 / \
	9  20
      /  \
	 15   7
	输出:
	[
	  [3],
	  [20,9],
	  [15,7]
	]
	

函数输入与输出：
* 输入：
	* struct TreeNode* root：二叉树的根节点指针
	* int** columnSizes：（*columnSizes）是指向数组的指针，也就是说columnSizes是二级指针
	* int* returnSize：*returnSize为二叉树的层数（深度）。
* 输出：
	* int**: 锯齿形层次遍历结果的二级指针

## 思路			

### 基于双端队列和BFS的层次遍历

	偶数层(0,2,4....)正序出队，正序进队，左孩子先顺序进队，右孩子后顺序进队
	奇数层(1,3,5....)逆序出队，逆序进队，右孩子先逆序进队，左孩子后逆序进队
	  3
	 / \
	9  20
      /  \
	 15   7
	讲一下这个遍历的过程吧:
	[1]刚开始3在队列中，队列长度为1，于是该层遍历1次，3的左右子树都不为空，于是将9,20先后顺序队，此时队列为[9,20]；
	[2]队列长度为2，该层遍历2次，第一次从队列逆序取出一个数20，其有左右子树分别为15、7。
	右孩子先逆序进队，做孩子后逆序进队，此时队列[15 7 9]；第二次从队列中逆序取出9，其没有左右子树。此时队列为[15,7]；
	[3]队列长度为2，该层遍历2次，第一次从队列中取出15，其没有左右子树，第二次从队列中取出7，其没有左右子树；
	[4]队列为空，结束。
	结果：
	[
	  [3],
	  [20,9],
	  [15,7]
	]
		
## 拓展与思考：
### 拓展
如果让你从最底层锯齿形遍历到最高层呢？
### 思考
本题很有意思，利用双端队列较为简单，也比较直接。当然你也可以用其他方法实现，比如结合堆栈与队列。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
