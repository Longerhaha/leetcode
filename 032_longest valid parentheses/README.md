# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 032_longest valid parentheses(最长有效括号)
## 问题描述与输入输出

### 问题描述

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

### 问题案例

	示例1
	输入: "(()"
	输出: 2
	解释: 最长有效括号子串为 "()"
	
	示例2
	输入: ")()())"
	输出: 4
	解释: 最长有效括号子串为 "()()"
	
## 思路			
### 堆栈法
入栈入的是该元素s[i]的_下标i_，每次遇见左括号则压栈，遇见右括号就得小心点了。遇见右括号处理如下：
* 如果此时栈空，则肯定无效，于是start位置加1
* 栈不空，则pop，pop后此时根据栈是否为空，可再分两种情况
	* 栈空，则更新max_valid_len为MAX(max_valid_len, (i-start+1))，由于可能继续增长，故不需要更新start
	* 栈不空，说明此时还有左括号在栈内，故只能根据栈顶元素（下标）来判断该匹配括号目前的有效括号长度，
	而且该长度可能会继续增长，于是更新max_valid_len为MAX(max_valid_len, i-stack_top_element(head))
### 动态规划	
dp[i]表示从s[0]到s[i]包含s[i]的最长的有效匹配括号子串长度，left表示包含s[i-1]最大配对的括号的前一个字符的
下标（left = i - dp[i-1] - 1），于是

dp[i] == dp[i-1]+2+dp[left] if(s[i] == ')' && s[left] == '('
      == 0, else
其中dp[left]=(left>0?dp[left-1]:0)

## 拓展与思考：
### 拓展
动态规划方法很好用，但是需要设置dp代表的含义，好的dp设计算法往往简单，本题动态规划算法也可以[逆序](https://blog.csdn.net/zzuzy/article/details/51223988)，大家可以思考一下。
### 思考
括号相关的基本都可以用堆栈做，本题动态规划也可以做，需要注意的是本题压栈的是该元素s[i]的_下标i_，这样后续才好处理。
        
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
