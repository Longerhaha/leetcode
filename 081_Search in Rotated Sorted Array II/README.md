# leetcode
# stick to it everyday and your will be a good algorithm engineer!
## 081_Search in Rotated Sorted Array II（搜索旋转排序数组II）
## 问题描述与输入输出
	
### 问题描述
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

### 问题案例
	
	示例1
	输入: nums = [2,5,6,0,0,1,2], target = 0
	输出: true
	
	示例2
	输入: nums = [2,5,6,0,0,1,2], target = 3
	输出: false
		
### 输入与输出
* 输入：
	* int* nums： 数据的头指针
	* numsSize：  数据的大小
	* int target：查找的目标

	
* 输出：
	* bool：是否存在这个元素

### 进阶

这是[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)的延伸题目，本题中的 nums  可能包含重复元素。

这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

	答：会影响，比如[1 3 1 1 1]这样的数据，我们想要查找3，首先发现左边（[1 3 1]）无序，于是去检查右边，可是再也检查不到了。
	也就是先前33的方法不能用的情况是nums[start]==nums[mid]==nums[end]的时候。
	从本程序来看，由于要跳过重复元素，在最坏情况下，所有的数据都一样，此时时间复杂度是O（n），平均复杂度还是O（logn）。

## 思路			
### 二分查找

	1.先跳过左边与中间重复的元素、右边与中间重复的元素（以中间靠拢的方向跳过）。
	2.判断是否满足递归结束的条件，即start与end相等或者刚好中间值是想要找的值。
	3.nums[start] < nums[end], 左有序，在左面范围内或者mid与end相等的时候只要搜索左边即可，否则搜索右边;
	  否则右有序，在右边范围内或者start与mid相等的时候只要搜索右边即可，否则搜索左边。
	例子：[1 3 1 1 1]，查找3
	
	start=0, mid=2, end=4;
	第1步跳过元素后，start==1, mid==end==2;
	第2步不满足递归结束条件，接着第3部;
	第3步3>1，所以是右有序，且搜索范围是左边。
	
	start=0, mid=0, end=1;
	第1步无需跳过元素;
	第2步不满足递归结束条件，接着第3部;
	第3步1<1不成立，右有序，且向右搜索。
	
	start=1, mid=1, end=1;
	第1步无需跳过元素;
	满足递归结束条件，且找到了，于是返回true。
	  
## 拓展与思考：
### 拓展
（1）如果数组中存在重复的元素并且让你返回目标的范围，那么又该怎么做？

（2）如果给的数据不是数组，而是链表，那么又该怎么做？还能实现O（logn）的复杂度吗？
### 思考
需要注意的是，在第一步跳过重复元素后，有三种情况。(1)start==mid，mid==end;(2)start==mid, mid!=end;(3)start!=mid, mid==end。
所以后续我们在第二、三步多考虑了这三种情况。
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
